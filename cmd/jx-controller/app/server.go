package app

import (
	"os"
	"time"

	log "github.com/sirupsen/logrus"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kubeclientset "k8s.io/client-go/kubernetes"
	restclientset "k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"

	"github.com/jiaxuanzhou/jx-controller/cmd/jx-controller/app/options"
	"github.com/jiaxuanzhou/jx-controller/apis/jx/v1alpha1"
	"github.com/jiaxuanzhou/jx-controller/pkg/util/signals"
)

const (
	apiVersion = "v1alpha1"
)

var (
	// leader election config
	leaseDuration = 15 * time.Second
	renewDuration = 5 * time.Second
	retryPeriod   = 3 * time.Second
	resyncPeriod  = 30 * time.Second
)

// KubeConfigPathEnv will be import from configMap or just from env of the deployment
const KubeConfigPathEnv = "KUBECONFIG"

func Run(opt *options.ServerOption) error {

	namespace := os.Getenv(v1alpha1.EnvJxNamespace)
	if len(namespace) == 0 {
		log.Infof("EnvJxNamespace not set, use default namespace")
		namespace = metav1.NamespaceDefault
	}

	// Set up signals so we handle the first shutdown signal gracefully.
	stopCh := signals.SetupSignalHandler()

	// Note: ENV KUBECONFIG will overwrite user defined Kubeconfig option.
	if len(os.Getenv(KubeConfigPathEnv)) > 0 {
		// use the current context in kubeconfig
		// This is very useful for running locally.
		opt.Kubeconfig = os.Getenv(KubeConfigPathEnv)
	}

	// Get kubernetes config.
	kcfg, err := clientcmd.BuildConfigFromFlags(opt.Master, opt.Kubeconfig)
	if err != nil {
		log.Fatalf("Error building kubeconfig: %s", err.Error())
	}

	// Create kube clients.

	// 1, Create informer factory.


	// 2, Create jx controller.


	// 3, Start informer goroutines.


	// 4, Set leader election start function.

	// 5. Prepare event clients.

	// 6, Start leader election.

	return nil
}

// fill the funcs when client code generated by v1alpha1
func createClientSets(config *restclientset.Config) (kubeclientset.Interface, kubeclientset.Interface, jxtaskclientset.Interface, error) {
	return
}
